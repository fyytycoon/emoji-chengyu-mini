{"version":3,"sources":["vue-mini.cjs.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*!\n * vue-mini v1.2.2\n * https://github.com/vue-mini/vue-mini\n * (c) 2019-present Yang Mingshan\n * @license MIT\n */\n\n\n/**\n* @vue/shared v3.5.13\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction makeMap(str) {\n  const map = /* @__PURE__ */ Object.create(null);\n  for (const key of str.split(\",\")) map[key] = 1;\n  return (val) => val in map;\n}\n\nconst EMPTY_OBJ$1 = Object.freeze({}) ;\nconst NOOP = () => {\n};\nconst extend$1 = Object.assign;\nconst remove = (arr, el) => {\n  const i = arr.indexOf(el);\n  if (i > -1) {\n    arr.splice(i, 1);\n  }\n};\nconst hasOwnProperty$1 = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty$1.call(val, key);\nconst isArray$1 = Array.isArray;\nconst isMap = (val) => toTypeString(val) === \"[object Map]\";\nconst isSet = (val) => toTypeString(val) === \"[object Set]\";\nconst isFunction$1 = (val) => typeof val === \"function\";\nconst isString = (val) => typeof val === \"string\";\nconst isSymbol = (val) => typeof val === \"symbol\";\nconst isObject$1 = (val) => val !== null && typeof val === \"object\";\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n  return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject$1 = (val) => toTypeString(val) === \"[object Object]\";\nconst isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\nconst cacheStringFunction = (fn) => {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n};\nconst capitalize = cacheStringFunction((str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst def = (obj, key, value, writable = false) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    writable,\n    value\n  });\n};\n\n/**\n* @vue/reactivity v3.5.13\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this._isPaused = false;\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n        this\n      ) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  pause() {\n    if (this._active) {\n      this._isPaused = true;\n      let i, l;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].pause();\n        }\n      }\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].pause();\n      }\n    }\n  }\n  /**\n   * Resumes the effect scope, including all child scopes and effects.\n   */\n  resume() {\n    if (this._active) {\n      if (this._isPaused) {\n        this._isPaused = false;\n        let i, l;\n        if (this.scopes) {\n          for (i = 0, l = this.scopes.length; i < l; i++) {\n            this.scopes[i].resume();\n          }\n        }\n        for (i = 0, l = this.effects.length; i < l; i++) {\n          this.effects[i].resume();\n        }\n      }\n    }\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    activeEffectScope = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    activeEffectScope = this.parent;\n  }\n  stop(fromParent) {\n    if (this._active) {\n      this._active = false;\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      this.effects.length = 0;\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      this.cleanups.length = 0;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n        this.scopes.length = 0;\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = undefined;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn, failSilently = false) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!failSilently) {\n    warn(\n      `onScopeDispose() is called when there is no active effect scope to be associated with.`\n    );\n  }\n}\n\nlet activeSub;\nconst pausedQueueEffects = /* @__PURE__ */ new WeakSet();\nclass ReactiveEffect {\n  constructor(fn) {\n    this.fn = fn;\n    /**\n     * @internal\n     */\n    this.deps = undefined;\n    /**\n     * @internal\n     */\n    this.depsTail = undefined;\n    /**\n     * @internal\n     */\n    this.flags = 1 | 4;\n    /**\n     * @internal\n     */\n    this.next = undefined;\n    /**\n     * @internal\n     */\n    this.cleanup = undefined;\n    this.scheduler = undefined;\n    if (activeEffectScope && activeEffectScope.active) {\n      activeEffectScope.effects.push(this);\n    }\n  }\n  pause() {\n    this.flags |= 64;\n  }\n  resume() {\n    if (this.flags & 64) {\n      this.flags &= -65;\n      if (pausedQueueEffects.has(this)) {\n        pausedQueueEffects.delete(this);\n        this.trigger();\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    if (this.flags & 2 && !(this.flags & 32)) {\n      return;\n    }\n    if (!(this.flags & 8)) {\n      batch(this);\n    }\n  }\n  run() {\n    if (!(this.flags & 1)) {\n      return this.fn();\n    }\n    this.flags |= 2;\n    cleanupEffect(this);\n    prepareDeps(this);\n    const prevEffect = activeSub;\n    const prevShouldTrack = shouldTrack;\n    activeSub = this;\n    shouldTrack = true;\n    try {\n      return this.fn();\n    } finally {\n      if (activeSub !== this) {\n        warn(\n          \"Active effect was not restored correctly - this is likely a Vue internal bug.\"\n        );\n      }\n      cleanupDeps(this);\n      activeSub = prevEffect;\n      shouldTrack = prevShouldTrack;\n      this.flags &= -3;\n    }\n  }\n  stop() {\n    if (this.flags & 1) {\n      for (let link = this.deps; link; link = link.nextDep) {\n        removeSub(link);\n      }\n      this.deps = this.depsTail = undefined;\n      cleanupEffect(this);\n      this.onStop && this.onStop();\n      this.flags &= -2;\n    }\n  }\n  trigger() {\n    if (this.flags & 64) {\n      pausedQueueEffects.add(this);\n    } else if (this.scheduler) {\n      this.scheduler();\n    } else {\n      this.runIfDirty();\n    }\n  }\n  /**\n   * @internal\n   */\n  runIfDirty() {\n    if (isDirty(this)) {\n      this.run();\n    }\n  }\n  get dirty() {\n    return isDirty(this);\n  }\n}\nlet batchDepth = 0;\nlet batchedSub;\nlet batchedComputed;\nfunction batch(sub, isComputed = false) {\n  sub.flags |= 8;\n  if (isComputed) {\n    sub.next = batchedComputed;\n    batchedComputed = sub;\n    return;\n  }\n  sub.next = batchedSub;\n  batchedSub = sub;\n}\nfunction startBatch() {\n  batchDepth++;\n}\nfunction endBatch() {\n  if (--batchDepth > 0) {\n    return;\n  }\n  if (batchedComputed) {\n    let e = batchedComputed;\n    batchedComputed = undefined;\n    while (e) {\n      const next = e.next;\n      e.next = undefined;\n      e.flags &= -9;\n      e = next;\n    }\n  }\n  let error;\n  while (batchedSub) {\n    let e = batchedSub;\n    batchedSub = undefined;\n    while (e) {\n      const next = e.next;\n      e.next = undefined;\n      e.flags &= -9;\n      if (e.flags & 1) {\n        try {\n          ;\n          e.trigger();\n        } catch (err) {\n          if (!error) error = err;\n        }\n      }\n      e = next;\n    }\n  }\n  if (error) throw error;\n}\nfunction prepareDeps(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    link.version = -1;\n    link.prevActiveLink = link.dep.activeLink;\n    link.dep.activeLink = link;\n  }\n}\nfunction cleanupDeps(sub) {\n  let head;\n  let tail = sub.depsTail;\n  let link = tail;\n  while (link) {\n    const prev = link.prevDep;\n    if (link.version === -1) {\n      if (link === tail) tail = prev;\n      removeSub(link);\n      removeDep(link);\n    } else {\n      head = link;\n    }\n    link.dep.activeLink = link.prevActiveLink;\n    link.prevActiveLink = undefined;\n    link = prev;\n  }\n  sub.deps = head;\n  sub.depsTail = tail;\n}\nfunction isDirty(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {\n      return true;\n    }\n  }\n  if (sub._dirty) {\n    return true;\n  }\n  return false;\n}\nfunction refreshComputed(computed) {\n  if (computed.flags & 4 && !(computed.flags & 16)) {\n    return;\n  }\n  computed.flags &= -17;\n  if (computed.globalVersion === globalVersion) {\n    return;\n  }\n  computed.globalVersion = globalVersion;\n  const dep = computed.dep;\n  computed.flags |= 2;\n  if (dep.version > 0 && !computed.isSSR && computed.deps && !isDirty(computed)) {\n    computed.flags &= -3;\n    return;\n  }\n  const prevSub = activeSub;\n  const prevShouldTrack = shouldTrack;\n  activeSub = computed;\n  shouldTrack = true;\n  try {\n    prepareDeps(computed);\n    const value = computed.fn(computed._value);\n    if (dep.version === 0 || hasChanged(value, computed._value)) {\n      computed._value = value;\n      dep.version++;\n    }\n  } catch (err) {\n    dep.version++;\n    throw err;\n  } finally {\n    activeSub = prevSub;\n    shouldTrack = prevShouldTrack;\n    cleanupDeps(computed);\n    computed.flags &= -3;\n  }\n}\nfunction removeSub(link, soft = false) {\n  const { dep, prevSub, nextSub } = link;\n  if (prevSub) {\n    prevSub.nextSub = nextSub;\n    link.prevSub = undefined;\n  }\n  if (nextSub) {\n    nextSub.prevSub = prevSub;\n    link.nextSub = undefined;\n  }\n  if (dep.subsHead === link) {\n    dep.subsHead = nextSub;\n  }\n  if (dep.subs === link) {\n    dep.subs = prevSub;\n    if (!prevSub && dep.computed) {\n      dep.computed.flags &= -5;\n      for (let l = dep.computed.deps; l; l = l.nextDep) {\n        removeSub(l, true);\n      }\n    }\n  }\n  if (!soft && !--dep.sc && dep.map) {\n    dep.map.delete(dep.key);\n  }\n}\nfunction removeDep(link) {\n  const { prevDep, nextDep } = link;\n  if (prevDep) {\n    prevDep.nextDep = nextDep;\n    link.prevDep = undefined;\n  }\n  if (nextDep) {\n    nextDep.prevDep = prevDep;\n    link.nextDep = undefined;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect instanceof ReactiveEffect) {\n    fn = fn.effect.fn;\n  }\n  const e = new ReactiveEffect(fn);\n  if (options) {\n    extend$1(e, options);\n  }\n  try {\n    e.run();\n  } catch (err) {\n    e.stop();\n    throw err;\n  }\n  const runner = e.run.bind(e);\n  runner.effect = e;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === undefined ? true : last;\n}\nfunction cleanupEffect(e) {\n  const { cleanup } = e;\n  e.cleanup = undefined;\n  if (cleanup) {\n    const prevSub = activeSub;\n    activeSub = undefined;\n    try {\n      cleanup();\n    } finally {\n      activeSub = prevSub;\n    }\n  }\n}\n\nlet globalVersion = 0;\nclass Link {\n  constructor(sub, dep) {\n    this.sub = sub;\n    this.dep = dep;\n    this.version = dep.version;\n    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = undefined;\n  }\n}\nclass Dep {\n  constructor(computed) {\n    this.computed = computed;\n    this.version = 0;\n    /**\n     * Link between this dep and the current active effect\n     */\n    this.activeLink = undefined;\n    /**\n     * Doubly linked list representing the subscribing effects (tail)\n     */\n    this.subs = undefined;\n    /**\n     * For object property deps cleanup\n     */\n    this.map = undefined;\n    this.key = undefined;\n    /**\n     * Subscriber counter\n     */\n    this.sc = 0;\n    {\n      this.subsHead = undefined;\n    }\n  }\n  track(debugInfo) {\n    if (!activeSub || !shouldTrack || activeSub === this.computed) {\n      return;\n    }\n    let link = this.activeLink;\n    if (link === undefined || link.sub !== activeSub) {\n      link = this.activeLink = new Link(activeSub, this);\n      if (!activeSub.deps) {\n        activeSub.deps = activeSub.depsTail = link;\n      } else {\n        link.prevDep = activeSub.depsTail;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n      }\n      addSub(link);\n    } else if (link.version === -1) {\n      link.version = this.version;\n      if (link.nextDep) {\n        const next = link.nextDep;\n        next.prevDep = link.prevDep;\n        if (link.prevDep) {\n          link.prevDep.nextDep = next;\n        }\n        link.prevDep = activeSub.depsTail;\n        link.nextDep = undefined;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n        if (activeSub.deps === link) {\n          activeSub.deps = next;\n        }\n      }\n    }\n    if (activeSub.onTrack) {\n      activeSub.onTrack(\n        extend$1(\n          {\n            effect: activeSub\n          },\n          debugInfo\n        )\n      );\n    }\n    return link;\n  }\n  trigger(debugInfo) {\n    this.version++;\n    globalVersion++;\n    this.notify(debugInfo);\n  }\n  notify(debugInfo) {\n    startBatch();\n    try {\n      if (!!(\"development\" !== \"production\")) {\n        for (let head = this.subsHead; head; head = head.nextSub) {\n          if (head.sub.onTrigger && !(head.sub.flags & 8)) {\n            head.sub.onTrigger(\n              extend$1(\n                {\n                  effect: head.sub\n                },\n                debugInfo\n              )\n            );\n          }\n        }\n      }\n      for (let link = this.subs; link; link = link.prevSub) {\n        if (link.sub.notify()) {\n          ;\n          link.sub.dep.notify();\n        }\n      }\n    } finally {\n      endBatch();\n    }\n  }\n}\nfunction addSub(link) {\n  link.dep.sc++;\n  if (link.sub.flags & 4) {\n    const computed = link.dep.computed;\n    if (computed && !link.dep.subs) {\n      computed.flags |= 4 | 16;\n      for (let l = computed.deps; l; l = l.nextDep) {\n        addSub(l);\n      }\n    }\n    const currentTail = link.dep.subs;\n    if (currentTail !== link) {\n      link.prevSub = currentTail;\n      if (currentTail) currentTail.nextSub = link;\n    }\n    if (link.dep.subsHead === undefined) {\n      link.dep.subsHead = link;\n    }\n    link.dep.subs = link;\n  }\n}\nconst targetMap = /* @__PURE__ */ new WeakMap();\nconst ITERATE_KEY = Symbol(\n  \"Object iterate\" \n);\nconst MAP_KEY_ITERATE_KEY = Symbol(\n  \"Map keys iterate\" \n);\nconst ARRAY_ITERATE_KEY = Symbol(\n  \"Array iterate\" \n);\nfunction track(target, type, key) {\n  if (shouldTrack && activeSub) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = new Dep());\n      dep.map = depsMap;\n      dep.key = key;\n    }\n    {\n      dep.track({\n        target,\n        type,\n        key\n      });\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    globalVersion++;\n    return;\n  }\n  const run = (dep) => {\n    if (dep) {\n      {\n        dep.trigger({\n          target,\n          type,\n          key,\n          newValue,\n          oldValue,\n          oldTarget\n        });\n      }\n    }\n  };\n  startBatch();\n  if (type === \"clear\") {\n    depsMap.forEach(run);\n  } else {\n    const targetIsArray = isArray$1(target);\n    const isArrayIndex = targetIsArray && isIntegerKey(key);\n    if (targetIsArray && key === \"length\") {\n      const newLength = Number(newValue);\n      depsMap.forEach((dep, key2) => {\n        if (key2 === \"length\" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {\n          run(dep);\n        }\n      });\n    } else {\n      if (key !== undefined || depsMap.has(undefined)) {\n        run(depsMap.get(key));\n      }\n      if (isArrayIndex) {\n        run(depsMap.get(ARRAY_ITERATE_KEY));\n      }\n      switch (type) {\n        case \"add\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          } else if (isArrayIndex) {\n            run(depsMap.get(\"length\"));\n          }\n          break;\n        case \"delete\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          }\n          break;\n        case \"set\":\n          if (isMap(target)) {\n            run(depsMap.get(ITERATE_KEY));\n          }\n          break;\n      }\n    }\n  }\n  endBatch();\n}\nfunction getDepFromReactive(object, key) {\n  const depMap = targetMap.get(object);\n  return depMap && depMap.get(key);\n}\n\nfunction reactiveReadArray(array) {\n  const raw = toRaw(array);\n  if (raw === array) return raw;\n  track(raw, \"iterate\", ARRAY_ITERATE_KEY);\n  return isShallow(array) ? raw : raw.map(toReactive);\n}\nfunction shallowReadArray(arr) {\n  track(arr = toRaw(arr), \"iterate\", ARRAY_ITERATE_KEY);\n  return arr;\n}\nconst arrayInstrumentations = {\n  __proto__: null,\n  [Symbol.iterator]() {\n    return iterator(this, Symbol.iterator, toReactive);\n  },\n  concat(...args) {\n    return reactiveReadArray(this).concat(\n      ...args.map((x) => isArray$1(x) ? reactiveReadArray(x) : x)\n    );\n  },\n  entries() {\n    return iterator(this, \"entries\", (value) => {\n      value[1] = toReactive(value[1]);\n      return value;\n    });\n  },\n  every(fn, thisArg) {\n    return apply(this, \"every\", fn, thisArg, undefined, arguments);\n  },\n  filter(fn, thisArg) {\n    return apply(this, \"filter\", fn, thisArg, (v) => v.map(toReactive), arguments);\n  },\n  find(fn, thisArg) {\n    return apply(this, \"find\", fn, thisArg, toReactive, arguments);\n  },\n  findIndex(fn, thisArg) {\n    return apply(this, \"findIndex\", fn, thisArg, undefined, arguments);\n  },\n  findLast(fn, thisArg) {\n    return apply(this, \"findLast\", fn, thisArg, toReactive, arguments);\n  },\n  findLastIndex(fn, thisArg) {\n    return apply(this, \"findLastIndex\", fn, thisArg, undefined, arguments);\n  },\n  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement\n  forEach(fn, thisArg) {\n    return apply(this, \"forEach\", fn, thisArg, undefined, arguments);\n  },\n  includes(...args) {\n    return searchProxy(this, \"includes\", args);\n  },\n  indexOf(...args) {\n    return searchProxy(this, \"indexOf\", args);\n  },\n  join(separator) {\n    return reactiveReadArray(this).join(separator);\n  },\n  // keys() iterator only reads `length`, no optimisation required\n  lastIndexOf(...args) {\n    return searchProxy(this, \"lastIndexOf\", args);\n  },\n  map(fn, thisArg) {\n    return apply(this, \"map\", fn, thisArg, undefined, arguments);\n  },\n  pop() {\n    return noTracking(this, \"pop\");\n  },\n  push(...args) {\n    return noTracking(this, \"push\", args);\n  },\n  reduce(fn, ...args) {\n    return reduce(this, \"reduce\", fn, args);\n  },\n  reduceRight(fn, ...args) {\n    return reduce(this, \"reduceRight\", fn, args);\n  },\n  shift() {\n    return noTracking(this, \"shift\");\n  },\n  // slice could use ARRAY_ITERATE but also seems to beg for range tracking\n  some(fn, thisArg) {\n    return apply(this, \"some\", fn, thisArg, undefined, arguments);\n  },\n  splice(...args) {\n    return noTracking(this, \"splice\", args);\n  },\n  toReversed() {\n    return reactiveReadArray(this).toReversed();\n  },\n  toSorted(comparer) {\n    return reactiveReadArray(this).toSorted(comparer);\n  },\n  toSpliced(...args) {\n    return reactiveReadArray(this).toSpliced(...args);\n  },\n  unshift(...args) {\n    return noTracking(this, \"unshift\", args);\n  },\n  values() {\n    return iterator(this, \"values\", toReactive);\n  }\n};\nfunction iterator(self, method, wrapValue) {\n  const arr = shallowReadArray(self);\n  const iter = arr[method]();\n  if (arr !== self && !isShallow(self)) {\n    iter._next = iter.next;\n    iter.next = () => {\n      const result = iter._next();\n      if (result.value) {\n        result.value = wrapValue(result.value);\n      }\n      return result;\n    };\n  }\n  return iter;\n}\nconst arrayProto = Array.prototype;\nfunction apply(self, method, fn, thisArg, wrappedRetFn, args) {\n  const arr = shallowReadArray(self);\n  const needsWrap = arr !== self && !isShallow(self);\n  const methodFn = arr[method];\n  if (methodFn !== arrayProto[method]) {\n    const result2 = methodFn.apply(self, args);\n    return needsWrap ? toReactive(result2) : result2;\n  }\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (needsWrap) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, toReactive(item), index, self);\n      };\n    } else if (fn.length > 2) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, item, index, self);\n      };\n    }\n  }\n  const result = methodFn.call(arr, wrappedFn, thisArg);\n  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;\n}\nfunction reduce(self, method, fn, args) {\n  const arr = shallowReadArray(self);\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (!isShallow(self)) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, toReactive(item), index, self);\n      };\n    } else if (fn.length > 3) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, item, index, self);\n      };\n    }\n  }\n  return arr[method](wrappedFn, ...args);\n}\nfunction searchProxy(self, method, args) {\n  const arr = toRaw(self);\n  track(arr, \"iterate\", ARRAY_ITERATE_KEY);\n  const res = arr[method](...args);\n  if ((res === -1 || res === false) && isProxy(args[0])) {\n    args[0] = toRaw(args[0]);\n    return arr[method](...args);\n  }\n  return res;\n}\nfunction noTracking(self, method, args = []) {\n  pauseTracking();\n  startBatch();\n  const res = toRaw(self)[method].apply(self, args);\n  endBatch();\n  resetTracking();\n  return res;\n}\n\nconst isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== \"arguments\" && key !== \"caller\").map((key) => Symbol[key]).filter(isSymbol)\n);\nfunction hasOwnProperty(key) {\n  if (!isSymbol(key)) key = String(key);\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nclass BaseReactiveHandler {\n  constructor(_isReadonly = false, _isShallow = false) {\n    this._isReadonly = _isReadonly;\n    this._isShallow = _isShallow;\n  }\n  get(target, key, receiver) {\n    if (key === \"__v_skip\") return target[\"__v_skip\"];\n    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return isShallow2;\n    } else if (key === \"__v_raw\") {\n      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype\n      // this means the receiver is a user proxy of the reactive proxy\n      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {\n        return target;\n      }\n      return;\n    }\n    const targetIsArray = isArray$1(target);\n    if (!isReadonly2) {\n      let fn;\n      if (targetIsArray && (fn = arrayInstrumentations[key])) {\n        return fn;\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(\n      target,\n      key,\n      // if this is a proxy wrapping a ref, return methods using the raw ref\n      // as receiver so that we don't have to call `toRaw` on the ref in all\n      // its class methods\n      isRef(target) ? target : receiver\n    );\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (isShallow2) {\n      return res;\n    }\n    if (isRef(res)) {\n      return targetIsArray && isIntegerKey(key) ? res : res.value;\n    }\n    if (isObject$1(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  }\n}\nclass MutableReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(false, isShallow2);\n  }\n  set(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (!this._isShallow) {\n      const isOldValueReadonly = isReadonly(oldValue);\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {\n        if (isOldValueReadonly) {\n          return false;\n        } else {\n          oldValue.value = value;\n          return true;\n        }\n      }\n    }\n    const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(\n      target,\n      key,\n      value,\n      isRef(target) ? target : receiver\n    );\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  }\n  deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, undefined, oldValue);\n    }\n    return result;\n  }\n  has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n    return result;\n  }\n  ownKeys(target) {\n    track(\n      target,\n      \"iterate\",\n      isArray$1(target) ? \"length\" : ITERATE_KEY\n    );\n    return Reflect.ownKeys(target);\n  }\n}\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(true, isShallow2);\n  }\n  set(target, key) {\n    {\n      warn(\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n  deleteProperty(target, key) {\n    {\n      warn(\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n}\nconst mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();\nconst readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();\nconst shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);\nconst shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction createIterableMethod(method, isReadonly2, isShallow2) {\n  return function(...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;\n    !isReadonly2 && track(\n      rawTarget,\n      \"iterate\",\n      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n    );\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      warn(\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\n        toRaw(this)\n      );\n    }\n    return type === \"delete\" ? false : type === \"clear\" ? undefined : this;\n  };\n}\nfunction createInstrumentations(readonly, shallow) {\n  const instrumentations = {\n    get(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"get\", key);\n        }\n        track(rawTarget, \"get\", rawKey);\n      }\n      const { has } = getProto(rawTarget);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n      } else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n      } else if (target !== rawTarget) {\n        target.get(key);\n      }\n    },\n    get size() {\n      const target = this[\"__v_raw\"];\n      !readonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n      return Reflect.get(target, \"size\", target);\n    },\n    has(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"has\", key);\n        }\n        track(rawTarget, \"has\", rawKey);\n      }\n      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n    },\n    forEach(callback, thisArg) {\n      const observed = this;\n      const target = observed[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      !readonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n      return target.forEach((value, key) => {\n        return callback.call(thisArg, wrap(value), wrap(key), observed);\n      });\n    }\n  };\n  extend$1(\n    instrumentations,\n    readonly ? {\n      add: createReadonlyMethod(\"add\"),\n      set: createReadonlyMethod(\"set\"),\n      delete: createReadonlyMethod(\"delete\"),\n      clear: createReadonlyMethod(\"clear\")\n    } : {\n      add(value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const proto = getProto(target);\n        const hadKey = proto.has.call(target, value);\n        if (!hadKey) {\n          target.add(value);\n          trigger(target, \"add\", value, value);\n        }\n        return this;\n      },\n      set(key, value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get.call(target, key);\n        target.set(key, value);\n        if (!hadKey) {\n          trigger(target, \"add\", key, value);\n        } else if (hasChanged(value, oldValue)) {\n          trigger(target, \"set\", key, value, oldValue);\n        }\n        return this;\n      },\n      delete(key) {\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get ? get.call(target, key) : undefined;\n        const result = target.delete(key);\n        if (hadKey) {\n          trigger(target, \"delete\", key, undefined, oldValue);\n        }\n        return result;\n      },\n      clear() {\n        const target = toRaw(this);\n        const hadItems = target.size !== 0;\n        const oldTarget = isMap(target) ? new Map(target) : new Set(target) ;\n        const result = target.clear();\n        if (hadItems) {\n          trigger(\n            target,\n            \"clear\",\n            undefined,\n            undefined,\n            oldTarget\n          );\n        }\n        return result;\n      }\n    }\n  );\n  const iteratorMethods = [\n    \"keys\",\n    \"values\",\n    \"entries\",\n    Symbol.iterator\n  ];\n  iteratorMethods.forEach((method) => {\n    instrumentations[method] = createIterableMethod(method, readonly, shallow);\n  });\n  return instrumentations;\n}\nfunction createInstrumentationGetter(isReadonly2, shallow) {\n  const instrumentations = createInstrumentations(isReadonly2, shallow);\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target ? instrumentations : target,\n      key,\n      receiver\n    );\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = toRawType(target);\n    warn(\n      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`\n    );\n  }\n}\n\nconst reactiveMap = /* @__PURE__ */ new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nconst readonlyMap = /* @__PURE__ */ new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  );\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  );\n}\nfunction readonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  );\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  );\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject$1(target)) {\n    {\n      warn(\n        `value cannot be made ${isReadonly2 ? \"readonly\" : \"reactive\"}: ${String(\n          target\n        )}`\n      );\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers\n  );\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return value ? !!value[\"__v_raw\"] : false;\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  if (!hasOwn(value, \"__v_skip\") && Object.isExtensible(value)) {\n    def(value, \"__v_skip\", true);\n  }\n  return value;\n}\nconst toReactive = (value) => isObject$1(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject$1(value) ? readonly(value) : value;\n\nfunction isRef(r) {\n  return r ? r[\"__v_isRef\"] === true : false;\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, isShallow2) {\n    this.dep = new Dep();\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isShallow\"] = false;\n    this._rawValue = isShallow2 ? value : toRaw(value);\n    this._value = isShallow2 ? value : toReactive(value);\n    this[\"__v_isShallow\"] = isShallow2;\n  }\n  get value() {\n    {\n      this.dep.track({\n        target: this,\n        type: \"get\",\n        key: \"value\"\n      });\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    const oldValue = this._rawValue;\n    const useDirectValue = this[\"__v_isShallow\"] || isShallow(newValue) || isReadonly(newValue);\n    newValue = useDirectValue ? newValue : toRaw(newValue);\n    if (hasChanged(newValue, oldValue)) {\n      this._rawValue = newValue;\n      this._value = useDirectValue ? newValue : toReactive(newValue);\n      {\n        this.dep.trigger({\n          target: this,\n          type: \"set\",\n          key: \"value\",\n          newValue,\n          oldValue\n        });\n      }\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  if (ref2.dep) {\n    {\n      ref2.dep.trigger({\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: ref2._value\n      });\n    }\n  }\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return isFunction$1(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => key === \"__v_raw\" ? target : unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this[\"__v_isRef\"] = true;\n    this._value = undefined;\n    const dep = this.dep = new Dep();\n    const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._value = this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (!isProxy(object)) {\n    warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = isArray$1(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this[\"__v_isRef\"] = true;\n    this._value = undefined;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return this._value = val === undefined ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isReadonly\"] = true;\n    this._value = undefined;\n  }\n  get value() {\n    return this._value = this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (isFunction$1(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject$1(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);\n}\n\nclass ComputedRefImpl {\n  constructor(fn, setter, isSSR) {\n    this.fn = fn;\n    this.setter = setter;\n    /**\n     * @internal\n     */\n    this._value = undefined;\n    /**\n     * @internal\n     */\n    this.dep = new Dep(this);\n    /**\n     * @internal\n     */\n    this.__v_isRef = true;\n    // TODO isolatedDeclarations \"__v_isReadonly\"\n    // A computed is also a subscriber that tracks other deps\n    /**\n     * @internal\n     */\n    this.deps = undefined;\n    /**\n     * @internal\n     */\n    this.depsTail = undefined;\n    /**\n     * @internal\n     */\n    this.flags = 16;\n    /**\n     * @internal\n     */\n    this.globalVersion = globalVersion - 1;\n    /**\n     * @internal\n     */\n    this.next = undefined;\n    // for backwards compat\n    this.effect = this;\n    this[\"__v_isReadonly\"] = !setter;\n    this.isSSR = isSSR;\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    this.flags |= 16;\n    if (!(this.flags & 8) && // avoid infinite self recursion\n    activeSub !== this) {\n      batch(this, true);\n      return true;\n    }\n  }\n  get value() {\n    const link = this.dep.track({\n      target: this,\n      type: \"get\",\n      key: \"value\"\n    }) ;\n    refreshComputed(this);\n    if (link) {\n      link.version = this.dep.version;\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    if (this.setter) {\n      this.setter(newValue);\n    } else {\n      warn(\"Write operation failed: computed value is readonly\");\n    }\n  }\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  if (isFunction$1(getterOrOptions)) {\n    getter = getterOrOptions;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, isSSR);\n  if (debugOptions && !isSSR) {\n    cRef.onTrack = debugOptions.onTrack;\n    cRef.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\n\nconst TrackOpTypes = {\n  \"GET\": \"get\",\n  \"HAS\": \"has\",\n  \"ITERATE\": \"iterate\"\n};\nconst TriggerOpTypes = {\n  \"SET\": \"set\",\n  \"ADD\": \"add\",\n  \"DELETE\": \"delete\",\n  \"CLEAR\": \"clear\"\n};\nconst INITIAL_WATCHER_VALUE = {};\nconst cleanupMap = /* @__PURE__ */ new WeakMap();\nlet activeWatcher = undefined;\nfunction getCurrentWatcher() {\n  return activeWatcher;\n}\nfunction onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {\n  if (owner) {\n    let cleanups = cleanupMap.get(owner);\n    if (!cleanups) cleanupMap.set(owner, cleanups = []);\n    cleanups.push(cleanupFn);\n  } else if (!failSilently) {\n    warn(\n      `onWatcherCleanup() was called when there was no active watcher to associate with.`\n    );\n  }\n}\nfunction watch$1(source, cb, options = EMPTY_OBJ$1) {\n  const { immediate, deep, once, scheduler, augmentJob, call } = options;\n  const warnInvalidSource = (s) => {\n    (options.onWarn || warn)(\n      `Invalid watch source: `,\n      s,\n      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`\n    );\n  };\n  const reactiveGetter = (source2) => {\n    if (deep) return source2;\n    if (isShallow(source2) || deep === false || deep === 0)\n      return traverse(source2, 1);\n    return traverse(source2);\n  };\n  let effect;\n  let getter;\n  let cleanup;\n  let boundCleanup;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if (isRef(source)) {\n    getter = () => source.value;\n    forceTrigger = isShallow(source);\n  } else if (isReactive(source)) {\n    getter = () => reactiveGetter(source);\n    forceTrigger = true;\n  } else if (isArray$1(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));\n    getter = () => source.map((s) => {\n      if (isRef(s)) {\n        return s.value;\n      } else if (isReactive(s)) {\n        return reactiveGetter(s);\n      } else if (isFunction$1(s)) {\n        return call ? call(s, 2) : s();\n      } else {\n        warnInvalidSource(s);\n      }\n    });\n  } else if (isFunction$1(source)) {\n    if (cb) {\n      getter = call ? () => call(source, 2) : source;\n    } else {\n      getter = () => {\n        if (cleanup) {\n          pauseTracking();\n          try {\n            cleanup();\n          } finally {\n            resetTracking();\n          }\n        }\n        const currentEffect = activeWatcher;\n        activeWatcher = effect;\n        try {\n          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);\n        } finally {\n          activeWatcher = currentEffect;\n        }\n      };\n    }\n  } else {\n    getter = NOOP;\n    warnInvalidSource(source);\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    const depth = deep === true ? Infinity : deep;\n    getter = () => traverse(baseGetter(), depth);\n  }\n  const scope = getCurrentScope();\n  const watchHandle = () => {\n    effect.stop();\n    if (scope && scope.active) {\n      remove(scope.effects, effect);\n    }\n  };\n  if (once && cb) {\n    const _cb = cb;\n    cb = (...args) => {\n      _cb(...args);\n      watchHandle();\n    };\n  }\n  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n  const job = (immediateFirstRun) => {\n    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {\n      return;\n    }\n    if (cb) {\n      const newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {\n        if (cleanup) {\n          cleanup();\n        }\n        const currentWatcher = activeWatcher;\n        activeWatcher = effect;\n        try {\n          const args = [\n            newValue,\n            // pass undefined as the old value when it's changed for the first time\n            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,\n            boundCleanup\n          ];\n          call ? call(cb, 3, args) : (\n            // @ts-expect-error\n            cb(...args)\n          );\n          oldValue = newValue;\n        } finally {\n          activeWatcher = currentWatcher;\n        }\n      }\n    } else {\n      effect.run();\n    }\n  };\n  if (augmentJob) {\n    augmentJob(job);\n  }\n  effect = new ReactiveEffect(getter);\n  effect.scheduler = scheduler ? () => scheduler(job, false) : job;\n  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect);\n  cleanup = effect.onStop = () => {\n    const cleanups = cleanupMap.get(effect);\n    if (cleanups) {\n      if (call) {\n        call(cleanups, 4);\n      } else {\n        for (const cleanup2 of cleanups) cleanup2();\n      }\n      cleanupMap.delete(effect);\n    }\n  };\n  {\n    effect.onTrack = options.onTrack;\n    effect.onTrigger = options.onTrigger;\n  }\n  if (cb) {\n    if (immediate) {\n      job(true);\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (scheduler) {\n    scheduler(job.bind(null, true), true);\n  } else {\n    effect.run();\n  }\n  watchHandle.pause = effect.pause.bind(effect);\n  watchHandle.resume = effect.resume.bind(effect);\n  watchHandle.stop = watchHandle;\n  return watchHandle;\n}\nfunction traverse(value, depth = Infinity, seen) {\n  if (depth <= 0 || !isObject$1(value) || value[\"__v_skip\"]) {\n    return value;\n  }\n  seen = seen || /* @__PURE__ */ new Set();\n  if (seen.has(value)) {\n    return value;\n  }\n  seen.add(value);\n  depth--;\n  if (isRef(value)) {\n    traverse(value.value, depth, seen);\n  } else if (isArray$1(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], depth, seen);\n    }\n  } else if (isSet(value) || isMap(value)) {\n    value.forEach((v) => {\n      traverse(v, depth, seen);\n    });\n  } else if (isPlainObject$1(value)) {\n    for (const key in value) {\n      traverse(value[key], depth, seen);\n    }\n    for (const key of Object.getOwnPropertySymbols(value)) {\n      if (Object.prototype.propertyIsEnumerable.call(value, key)) {\n        traverse(value[key], depth, seen);\n      }\n    }\n  }\n  return value;\n}\n\nconst EMPTY_OBJ = Object.freeze({}) ;\nconst { isArray } = Array;\nconst extend = Object.assign;\nfunction exclude(obj, keys) {\n    const ret = {};\n    Object.keys(obj).forEach((key) => {\n        if (!keys.includes(key)) {\n            ret[key] = obj[key];\n        }\n    });\n    return ret;\n}\nfunction getType(x) {\n    return Object.prototype.toString.call(x).slice(8, -1);\n}\nfunction isSimpleValue(x) {\n    const simpleTypes = new Set(['undefined', 'boolean', 'number', 'string']);\n    return x === null || simpleTypes.has(typeof x);\n}\nfunction isObject(x) {\n    return x !== null && typeof x === 'object';\n}\nfunction isPlainObject(x) {\n    return getType(x) === 'Object';\n}\nfunction isFunction(x) {\n    return typeof x === 'function';\n}\nfunction toHiddenField(name) {\n    return `__${name}__`;\n}\n\n/* eslint-disable no-bitwise, unicorn/prefer-math-trunc, @typescript-eslint/prefer-literal-enum-member */\nvar SchedulerJobFlags;\n(function (SchedulerJobFlags) {\n    SchedulerJobFlags[SchedulerJobFlags[\"QUEUED\"] = 1] = \"QUEUED\";\n    SchedulerJobFlags[SchedulerJobFlags[\"ALLOW_RECURSE\"] = 4] = \"ALLOW_RECURSE\";\n})(SchedulerJobFlags || (SchedulerJobFlags = {}));\nconst queue = [];\nlet flushIndex = -1;\nconst pendingPostFlushCbs = [];\nlet activePostFlushCbs = null;\nlet postFlushIndex = 0;\n// eslint-disable-next-line spaced-comment\nconst resolvedPromise = /*@__PURE__*/ Promise.resolve();\nlet currentFlushPromise = null;\nconst RECURSION_LIMIT = 100;\nfunction nextTick(fn) {\n    const p = currentFlushPromise || resolvedPromise;\n    // eslint-disable-next-line promise/prefer-await-to-then\n    return fn ? p.then(fn) : p;\n}\nfunction queueJob(job) {\n    if (!(job.flags & SchedulerJobFlags.QUEUED)) {\n        queue.push(job);\n        job.flags |= SchedulerJobFlags.QUEUED;\n        queueFlush();\n    }\n}\nfunction queueFlush() {\n    if (!currentFlushPromise) {\n        // eslint-disable-next-line promise/prefer-await-to-then\n        currentFlushPromise = resolvedPromise.then(flushJobs);\n    }\n}\nfunction queuePostFlushCb(cb) {\n    if (!(cb.flags & SchedulerJobFlags.QUEUED)) {\n        pendingPostFlushCbs.push(cb);\n        cb.flags |= SchedulerJobFlags.QUEUED;\n    }\n}\nfunction flushPostFlushCbs() {\n    if (pendingPostFlushCbs.length > 0) {\n        activePostFlushCbs = [...new Set(pendingPostFlushCbs)];\n        pendingPostFlushCbs.length = 0;\n        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\n            const cb = activePostFlushCbs[postFlushIndex];\n            if (cb.flags & SchedulerJobFlags.ALLOW_RECURSE) {\n                cb.flags &= ~SchedulerJobFlags.QUEUED;\n            }\n            cb();\n            cb.flags &= ~SchedulerJobFlags.QUEUED;\n        }\n        activePostFlushCbs = null;\n        postFlushIndex = 0;\n    }\n}\nfunction flushJobs(seen) {\n    /* istanbul ignore else -- @preserve  */\n    {\n        seen = seen || new Map();\n    }\n    // Conditional usage of checkRecursiveUpdate must be determined out of\n    // try ... catch block since Rollup by default de-optimizes treeshaking\n    // inside try-catch. This can leave all warning code unshaked. Although\n    // they would get eventually shaken by a minifier like terser, some minifiers\n    // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)\n    const check = (job) => checkRecursiveUpdates(seen, job)\n        ;\n    try {\n        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n            const job = queue[flushIndex];\n            /* istanbul ignore if -- @preserve  */\n            if (true && check(job)) {\n                continue;\n            }\n            if (job.flags & SchedulerJobFlags.ALLOW_RECURSE) {\n                job.flags &= ~SchedulerJobFlags.QUEUED;\n            }\n            job();\n            if (!(job.flags & SchedulerJobFlags.ALLOW_RECURSE)) {\n                job.flags &= ~SchedulerJobFlags.QUEUED;\n            }\n        }\n    }\n    finally {\n        // If there was an error we still need to clear the QUEUED flags\n        for (; flushIndex < queue.length; flushIndex++) {\n            const job = queue[flushIndex];\n            job.flags &= ~SchedulerJobFlags.QUEUED;\n        }\n        flushIndex = -1;\n        queue.length = 0;\n        currentFlushPromise = null;\n    }\n}\nfunction checkRecursiveUpdates(seen, fn) {\n    const count = seen.get(fn) || 0;\n    /* istanbul ignore if -- @preserve */\n    if (count > RECURSION_LIMIT) {\n        console.warn(`Maximum recursive updates exceeded. ` +\n            `This means you have a reactive effect that is mutating its own ` +\n            `dependencies and thus recursively triggering itself.`);\n        return true;\n    }\n    seen.set(fn, count + 1);\n    return false;\n}\n\n// Simple effect.\nfunction watchEffect(effect, options) {\n    return doWatch(effect, null, options);\n}\nfunction watchPostEffect(effect, options) {\n    return doWatch(effect, null, extend({}, options, { flush: 'post' })\n        );\n}\nfunction watchSyncEffect(effect, options) {\n    return doWatch(effect, null, extend({}, options, { flush: 'sync' })\n        );\n}\n// Implementation\nfunction watch(source, cb, options) {\n    if (!isFunction(cb)) {\n        console.warn(`\\`watch(fn, options?)\\` signature has been moved to a separate API. ` +\n            `Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only ` +\n            `supports \\`watch(source, cb, options?) signature.`);\n    }\n    return doWatch(source, cb, options);\n}\nfunction doWatch(source, cb, options = EMPTY_OBJ) {\n    const { immediate, deep, flush, once } = options;\n    if (!cb) {\n        if (immediate !== undefined) {\n            console.warn(`watch() \"immediate\" option is only respected when using the ` +\n                `watch(source, callback, options?) signature.`);\n        }\n        if (deep !== undefined) {\n            console.warn(`watch() \"deep\" option is only respected when using the ` +\n                `watch(source, callback, options?) signature.`);\n        }\n        if (once !== undefined) {\n            console.warn(`watch() \"once\" option is only respected when using the ` +\n                `watch(source, callback, options?) signature.`);\n        }\n    }\n    const baseWatchOptions = extend({}, options);\n    // Scheduler\n    if (flush === 'post') {\n        baseWatchOptions.scheduler = (job) => {\n            queuePostFlushCb(job);\n        };\n    }\n    else if (flush !== 'sync') {\n        baseWatchOptions.scheduler = (job, isFirstRun) => {\n            if (isFirstRun) {\n                job();\n            }\n            else {\n                queueJob(job);\n            }\n        };\n    }\n    // @ts-expect-error\n    baseWatchOptions.augmentJob = (job) => {\n        // Important: mark the job as a watcher callback so that scheduler knows\n        // it is allowed to self-trigger\n        if (cb) {\n            // eslint-disable-next-line no-bitwise\n            job.flags |= SchedulerJobFlags.ALLOW_RECURSE;\n        }\n    };\n    const watchHandle = watch$1(source, cb, baseWatchOptions);\n    return watchHandle;\n}\n\nconst provides = Object.create(null);\nfunction provide(key, value) {\n    // TS doesn't allow symbol as index type\n    provides[key] = value;\n}\nfunction inject(key, defaultValue, treatDefaultAsFactory = false) {\n    if (key in provides) {\n        // TS doesn't allow symbol as index type\n        return provides[key];\n    }\n    if (arguments.length > 1) {\n        return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue()\n            : defaultValue;\n    }\n    /* istanbul ignore else -- @preserve */\n    {\n        console.warn(`injection \"${String(key)}\" not found.`);\n    }\n}\n\nlet currentApp = null;\nlet currentPage = null;\nlet currentComponent = null;\nfunction getCurrentInstance() {\n    return currentPage || currentComponent;\n}\nfunction setCurrentApp(app) {\n    currentApp = app;\n}\nfunction unsetCurrentApp() {\n    currentApp = null;\n}\nfunction setCurrentPage(page) {\n    currentPage = page;\n    // @ts-expect-error\n    page.__scope__.on();\n}\nfunction unsetCurrentPage() {\n    /* istanbul ignore else -- @preserve */\n    if (currentPage) {\n        // @ts-expect-error\n        currentPage.__scope__.off();\n    }\n    currentPage = null;\n}\nfunction setCurrentComponent(component) {\n    currentComponent = component;\n    // @ts-expect-error\n    component.__scope__.on();\n}\nfunction unsetCurrentComponent() {\n    /* istanbul ignore else -- @preserve */\n    if (currentComponent) {\n        // @ts-expect-error\n        currentComponent.__scope__.off();\n    }\n    currentComponent = null;\n}\n\nvar AppLifecycle;\n(function (AppLifecycle) {\n    AppLifecycle[\"ON_LAUNCH\"] = \"onLaunch\";\n    AppLifecycle[\"ON_SHOW\"] = \"onShow\";\n    AppLifecycle[\"ON_HIDE\"] = \"onHide\";\n    AppLifecycle[\"ON_ERROR\"] = \"onError\";\n    AppLifecycle[\"ON_PAGE_NOT_FOUND\"] = \"onPageNotFound\";\n    AppLifecycle[\"ON_UNHANDLED_REJECTION\"] = \"onUnhandledRejection\";\n    AppLifecycle[\"ON_THEME_CHANGE\"] = \"onThemeChange\";\n})(AppLifecycle || (AppLifecycle = {}));\nfunction createApp(optionsOrSetup) {\n    let setup;\n    let options;\n    if (isFunction(optionsOrSetup)) {\n        setup = optionsOrSetup;\n        options = {};\n    }\n    else {\n        if (optionsOrSetup.setup === undefined) {\n            // eslint-disable-next-line new-cap\n            App(optionsOrSetup);\n            return;\n        }\n        setup = optionsOrSetup.setup;\n        options = exclude(optionsOrSetup, ['setup']);\n    }\n    const originOnLaunch = options[AppLifecycle.ON_LAUNCH];\n    options[AppLifecycle.ON_LAUNCH] = function (options) {\n        setCurrentApp(this);\n        const bindings = setup(options);\n        if (bindings !== undefined) {\n            Object.keys(bindings).forEach((key) => {\n                this[key] = bindings[key];\n            });\n        }\n        unsetCurrentApp();\n        if (originOnLaunch !== undefined) {\n            originOnLaunch.call(this, options);\n        }\n    };\n    options[AppLifecycle.ON_SHOW] = createLifecycle$2(options, AppLifecycle.ON_SHOW);\n    options[AppLifecycle.ON_HIDE] = createLifecycle$2(options, AppLifecycle.ON_HIDE);\n    options[AppLifecycle.ON_ERROR] = createLifecycle$2(options, AppLifecycle.ON_ERROR);\n    options[AppLifecycle.ON_PAGE_NOT_FOUND] = createLifecycle$2(options, AppLifecycle.ON_PAGE_NOT_FOUND);\n    options[AppLifecycle.ON_UNHANDLED_REJECTION] = createLifecycle$2(options, AppLifecycle.ON_UNHANDLED_REJECTION);\n    options[AppLifecycle.ON_THEME_CHANGE] = createLifecycle$2(options, AppLifecycle.ON_THEME_CHANGE);\n    // eslint-disable-next-line new-cap\n    App(options);\n}\nfunction createLifecycle$2(options, lifecycle) {\n    const originLifecycle = options[lifecycle];\n    return function (...args) {\n        const hooks = this[toHiddenField(lifecycle)];\n        if (hooks) {\n            hooks.forEach((hook) => hook(...args));\n        }\n        if (originLifecycle !== undefined) {\n            originLifecycle.call(this, ...args);\n        }\n    };\n}\n\nfunction deepToRaw(x) {\n    if (isSimpleValue(x) || isFunction(x)) {\n        return x;\n    }\n    if (isRef(x)) {\n        return deepToRaw(x.value);\n    }\n    if (isProxy(x)) {\n        return deepToRaw(toRaw(x));\n    }\n    if (isArray(x)) {\n        return x.map((item) => deepToRaw(item));\n    }\n    if (isPlainObject(x)) {\n        const obj = {};\n        Object.keys(x).forEach((key) => {\n            obj[key] = deepToRaw(x[key]);\n        });\n        return obj;\n    }\n    throw new TypeError(`${getType(x)} value is not supported`);\n}\nfunction deepWatch(key, value) {\n    if (!isObject(value)) {\n        return;\n    }\n    watch(isRef(value) ? value : () => value, () => {\n        this.setData({ [key]: deepToRaw(value) }, flushPostFlushCbs);\n    }, {\n        deep: true,\n    });\n}\n\nvar PageLifecycle;\n(function (PageLifecycle) {\n    PageLifecycle[\"ON_LOAD\"] = \"onLoad\";\n    PageLifecycle[\"ON_SHOW\"] = \"onShow\";\n    PageLifecycle[\"ON_READY\"] = \"onReady\";\n    PageLifecycle[\"ON_HIDE\"] = \"onHide\";\n    PageLifecycle[\"ON_UNLOAD\"] = \"onUnload\";\n    PageLifecycle[\"ON_ROUTE_DONE\"] = \"onRouteDone\";\n    PageLifecycle[\"ON_PULL_DOWN_REFRESH\"] = \"onPullDownRefresh\";\n    PageLifecycle[\"ON_REACH_BOTTOM\"] = \"onReachBottom\";\n    PageLifecycle[\"ON_PAGE_SCROLL\"] = \"onPageScroll\";\n    PageLifecycle[\"ON_SHARE_APP_MESSAGE\"] = \"onShareAppMessage\";\n    PageLifecycle[\"ON_SHARE_TIMELINE\"] = \"onShareTimeline\";\n    PageLifecycle[\"ON_ADD_TO_FAVORITES\"] = \"onAddToFavorites\";\n    PageLifecycle[\"ON_RESIZE\"] = \"onResize\";\n    PageLifecycle[\"ON_TAB_ITEM_TAP\"] = \"onTabItemTap\";\n    PageLifecycle[\"ON_SAVE_EXIT_STATE\"] = \"onSaveExitState\";\n})(PageLifecycle || (PageLifecycle = {}));\nfunction definePage(optionsOrSetup, config) {\n    config = extend({\n        listenPageScroll: false,\n        canShareToOthers: false,\n        canShareToTimeline: false,\n    }, config);\n    let setup;\n    let options;\n    if (isFunction(optionsOrSetup)) {\n        setup = optionsOrSetup;\n        options = {};\n    }\n    else {\n        if (optionsOrSetup.setup === undefined) {\n            // eslint-disable-next-line new-cap\n            Page(optionsOrSetup);\n            return;\n        }\n        setup = optionsOrSetup.setup;\n        options = exclude(optionsOrSetup, ['setup']);\n    }\n    const originOnLoad = options[PageLifecycle.ON_LOAD];\n    options[PageLifecycle.ON_LOAD] = function (query) {\n        this.__scope__ = new EffectScope();\n        setCurrentPage(this);\n        const context = {\n            is: this.is,\n            route: this.route,\n            options: this.options,\n            exitState: this.exitState,\n            router: this.router,\n            pageRouter: this.pageRouter,\n            renderer: this.renderer,\n            createSelectorQuery: this.createSelectorQuery.bind(this),\n            createIntersectionObserver: this.createIntersectionObserver.bind(this),\n            createMediaQueryObserver: this.createMediaQueryObserver.bind(this),\n            selectComponent: this.selectComponent.bind(this),\n            selectAllComponents: this.selectAllComponents.bind(this),\n            getTabBar: this.getTabBar.bind(this),\n            getPageId: this.getPageId.bind(this),\n            animate: this.animate.bind(this),\n            clearAnimation: this.clearAnimation.bind(this),\n            getOpenerEventChannel: this.getOpenerEventChannel.bind(this),\n            applyAnimatedStyle: this.applyAnimatedStyle.bind(this),\n            clearAnimatedStyle: this.clearAnimatedStyle.bind(this),\n            setUpdatePerformanceListener: this.setUpdatePerformanceListener.bind(this),\n            getPassiveEvent: this.getPassiveEvent.bind(this),\n            setPassiveEvent: this.setPassiveEvent.bind(this),\n            setInitialRenderingCache: this.setInitialRenderingCache.bind(this),\n            getAppBar: this.getAppBar && this.getAppBar.bind(this),\n        };\n        const bindings = setup(query, context);\n        if (bindings !== undefined) {\n            let data;\n            Object.keys(bindings).forEach((key) => {\n                const value = bindings[key];\n                if (isFunction(value)) {\n                    this[key] = value;\n                    return;\n                }\n                data = data || {};\n                data[key] = deepToRaw(value);\n                deepWatch.call(this, key, value);\n            });\n            if (data !== undefined) {\n                this.setData(data, flushPostFlushCbs);\n            }\n        }\n        unsetCurrentPage();\n        if (originOnLoad !== undefined) {\n            originOnLoad.call(this, query);\n        }\n    };\n    const onUnload = createLifecycle$1(options, PageLifecycle.ON_UNLOAD);\n    options[PageLifecycle.ON_UNLOAD] = function () {\n        onUnload.call(this);\n        this.__scope__.stop();\n    };\n    if (options[PageLifecycle.ON_PAGE_SCROLL] || config.listenPageScroll) {\n        options[PageLifecycle.ON_PAGE_SCROLL] = createLifecycle$1(options, PageLifecycle.ON_PAGE_SCROLL);\n        /* istanbul ignore next -- @preserve */\n        options.__listenPageScroll__ = () => true;\n    }\n    if (options[PageLifecycle.ON_SHARE_APP_MESSAGE] === undefined &&\n        config.canShareToOthers) {\n        options[PageLifecycle.ON_SHARE_APP_MESSAGE] = function (share) {\n            const hook = this[toHiddenField(PageLifecycle.ON_SHARE_APP_MESSAGE)];\n            if (hook) {\n                return hook(share);\n            }\n            return {};\n        };\n        /* istanbul ignore next -- @preserve */\n        options.__isInjectedShareToOthersHook__ = () => true;\n    }\n    if (options[PageLifecycle.ON_SHARE_TIMELINE] === undefined &&\n        config.canShareToTimeline) {\n        options[PageLifecycle.ON_SHARE_TIMELINE] = function () {\n            const hook = this[toHiddenField(PageLifecycle.ON_SHARE_TIMELINE)];\n            if (hook) {\n                return hook();\n            }\n            return {};\n        };\n        /* istanbul ignore next -- @preserve */\n        options.__isInjectedShareToTimelineHook__ = () => true;\n    }\n    if (options[PageLifecycle.ON_ADD_TO_FAVORITES] === undefined) {\n        options[PageLifecycle.ON_ADD_TO_FAVORITES] = function (favorites) {\n            const hook = this[toHiddenField(PageLifecycle.ON_ADD_TO_FAVORITES)];\n            if (hook) {\n                return hook(favorites);\n            }\n            return {};\n        };\n        /* istanbul ignore next -- @preserve */\n        options.__isInjectedFavoritesHook__ = () => true;\n    }\n    if (options[PageLifecycle.ON_SAVE_EXIT_STATE] === undefined) {\n        options[PageLifecycle.ON_SAVE_EXIT_STATE] = function () {\n            const hook = this[toHiddenField(PageLifecycle.ON_SAVE_EXIT_STATE)];\n            if (hook) {\n                return hook();\n            }\n            return { data: undefined };\n        };\n        /* istanbul ignore next -- @preserve */\n        options.__isInjectedExitStateHook__ = () => true;\n    }\n    options[PageLifecycle.ON_SHOW] = createLifecycle$1(options, PageLifecycle.ON_SHOW);\n    options[PageLifecycle.ON_READY] = createLifecycle$1(options, PageLifecycle.ON_READY);\n    options[PageLifecycle.ON_HIDE] = createLifecycle$1(options, PageLifecycle.ON_HIDE);\n    options[PageLifecycle.ON_ROUTE_DONE] = createLifecycle$1(options, PageLifecycle.ON_ROUTE_DONE);\n    options[PageLifecycle.ON_PULL_DOWN_REFRESH] = createLifecycle$1(options, PageLifecycle.ON_PULL_DOWN_REFRESH);\n    options[PageLifecycle.ON_REACH_BOTTOM] = createLifecycle$1(options, PageLifecycle.ON_REACH_BOTTOM);\n    options[PageLifecycle.ON_RESIZE] = createLifecycle$1(options, PageLifecycle.ON_RESIZE);\n    options[PageLifecycle.ON_TAB_ITEM_TAP] = createLifecycle$1(options, PageLifecycle.ON_TAB_ITEM_TAP);\n    // eslint-disable-next-line new-cap\n    Page(options);\n}\nfunction createLifecycle$1(options, lifecycle) {\n    const originLifecycle = options[lifecycle];\n    return function (...args) {\n        const hooks = this[toHiddenField(lifecycle)];\n        if (hooks) {\n            hooks.forEach((hook) => hook(...args));\n        }\n        if (originLifecycle !== undefined) {\n            originLifecycle.call(this, ...args);\n        }\n    };\n}\n\nvar ComponentLifecycle;\n(function (ComponentLifecycle) {\n    ComponentLifecycle[\"ATTACHED\"] = \"attached\";\n    ComponentLifecycle[\"READY\"] = \"ready\";\n    ComponentLifecycle[\"MOVED\"] = \"moved\";\n    ComponentLifecycle[\"DETACHED\"] = \"detached\";\n    ComponentLifecycle[\"ERROR\"] = \"error\";\n})(ComponentLifecycle || (ComponentLifecycle = {}));\nconst SpecialLifecycleMap = {\n    [PageLifecycle.ON_SHOW]: 'show',\n    [PageLifecycle.ON_HIDE]: 'hide',\n    [PageLifecycle.ON_RESIZE]: 'resize',\n    [PageLifecycle.ON_ROUTE_DONE]: 'routeDone',\n    [ComponentLifecycle.READY]: PageLifecycle.ON_READY,\n};\nfunction defineComponent(optionsOrSetup, config) {\n    config = extend({\n        listenPageScroll: false,\n        canShareToOthers: false,\n        canShareToTimeline: false,\n    }, config);\n    let setup;\n    let options;\n    let properties = null;\n    if (isFunction(optionsOrSetup)) {\n        setup = optionsOrSetup;\n        options = {};\n    }\n    else {\n        if (optionsOrSetup.setup === undefined) {\n            // eslint-disable-next-line new-cap\n            return Component(optionsOrSetup);\n        }\n        setup = optionsOrSetup.setup;\n        options = exclude(optionsOrSetup, ['setup']);\n        if (options.properties) {\n            properties = Object.keys(options.properties);\n        }\n    }\n    if (options.lifetimes === undefined) {\n        options.lifetimes = {};\n    }\n    const originAttached = options.lifetimes[ComponentLifecycle.ATTACHED] ||\n        options[ComponentLifecycle.ATTACHED];\n    options.lifetimes[ComponentLifecycle.ATTACHED] = function () {\n        this.__scope__ = new EffectScope();\n        setCurrentComponent(this);\n        const rawProps = {};\n        if (properties) {\n            properties.forEach((property) => {\n                rawProps[property] = this.data[property];\n            });\n        }\n        this.__props__ = shallowReactive(rawProps);\n        const context = {\n            is: this.is,\n            id: this.id,\n            dataset: this.dataset,\n            exitState: this.exitState,\n            router: this.router,\n            pageRouter: this.pageRouter,\n            renderer: this.renderer,\n            triggerEvent: this.triggerEvent.bind(this),\n            createSelectorQuery: this.createSelectorQuery.bind(this),\n            createIntersectionObserver: this.createIntersectionObserver.bind(this),\n            createMediaQueryObserver: this.createMediaQueryObserver.bind(this),\n            selectComponent: this.selectComponent.bind(this),\n            selectAllComponents: this.selectAllComponents.bind(this),\n            selectOwnerComponent: this.selectOwnerComponent.bind(this),\n            getRelationNodes: this.getRelationNodes.bind(this),\n            getTabBar: this.getTabBar.bind(this),\n            getPageId: this.getPageId.bind(this),\n            animate: this.animate.bind(this),\n            clearAnimation: this.clearAnimation.bind(this),\n            getOpenerEventChannel: this.getOpenerEventChannel.bind(this),\n            applyAnimatedStyle: this.applyAnimatedStyle.bind(this),\n            clearAnimatedStyle: this.clearAnimatedStyle.bind(this),\n            setUpdatePerformanceListener: this.setUpdatePerformanceListener.bind(this),\n            getPassiveEvent: this.getPassiveEvent.bind(this),\n            setPassiveEvent: this.setPassiveEvent.bind(this),\n            setInitialRenderingCache: this.setInitialRenderingCache.bind(this),\n            getAppBar: this.getAppBar && this.getAppBar.bind(this),\n        };\n        const bindings = setup(shallowReadonly(this.__props__)\n            , context);\n        if (bindings !== undefined) {\n            let data;\n            Object.keys(bindings).forEach((key) => {\n                const value = bindings[key];\n                if (isFunction(value)) {\n                    this[key] = value;\n                    return;\n                }\n                data = data || {};\n                data[key] = deepToRaw(value);\n                deepWatch.call(this, key, value);\n            });\n            if (data !== undefined) {\n                this.setData(data, flushPostFlushCbs);\n            }\n        }\n        unsetCurrentComponent();\n        if (originAttached !== undefined) {\n            originAttached.call(this);\n        }\n    };\n    const detached = createComponentLifecycle(options, ComponentLifecycle.DETACHED);\n    options.lifetimes[ComponentLifecycle.DETACHED] = function () {\n        detached.call(this);\n        this.__scope__.stop();\n    };\n    const originReady = options.lifetimes[ComponentLifecycle.READY] ||\n        options[ComponentLifecycle.READY];\n    options.lifetimes[ComponentLifecycle.READY] = createLifecycle(SpecialLifecycleMap[ComponentLifecycle.READY], originReady);\n    options.lifetimes[ComponentLifecycle.MOVED] = createComponentLifecycle(options, ComponentLifecycle.MOVED);\n    options.lifetimes[ComponentLifecycle.ERROR] = createComponentLifecycle(options, ComponentLifecycle.ERROR);\n    if (options.methods === undefined) {\n        options.methods = {};\n    }\n    if (options.methods[PageLifecycle.ON_PAGE_SCROLL] ||\n        config.listenPageScroll) {\n        options.methods[PageLifecycle.ON_PAGE_SCROLL] = createPageLifecycle(options, PageLifecycle.ON_PAGE_SCROLL);\n        /* istanbul ignore next -- @preserve */\n        options.methods.__listenPageScroll__ = () => true;\n    }\n    if (options.methods[PageLifecycle.ON_SHARE_APP_MESSAGE] === undefined &&\n        config.canShareToOthers) {\n        options.methods[PageLifecycle.ON_SHARE_APP_MESSAGE] = function (share) {\n            const hook = this[toHiddenField(PageLifecycle.ON_SHARE_APP_MESSAGE)];\n            if (hook) {\n                return hook(share);\n            }\n            return {};\n        };\n        /* istanbul ignore next -- @preserve */\n        options.methods.__isInjectedShareToOthersHook__ = () => true;\n    }\n    if (options.methods[PageLifecycle.ON_SHARE_TIMELINE] === undefined &&\n        config.canShareToTimeline) {\n        options.methods[PageLifecycle.ON_SHARE_TIMELINE] = function () {\n            const hook = this[toHiddenField(PageLifecycle.ON_SHARE_TIMELINE)];\n            if (hook) {\n                return hook();\n            }\n            return {};\n        };\n        /* istanbul ignore next -- @preserve */\n        options.methods.__isInjectedShareToTimelineHook__ = () => true;\n    }\n    if (options.methods[PageLifecycle.ON_ADD_TO_FAVORITES] === undefined) {\n        options.methods[PageLifecycle.ON_ADD_TO_FAVORITES] = function (favorites) {\n            const hook = this[toHiddenField(PageLifecycle.ON_ADD_TO_FAVORITES)];\n            if (hook) {\n                return hook(favorites);\n            }\n            return {};\n        };\n        /* istanbul ignore next -- @preserve */\n        options.methods.__isInjectedFavoritesHook__ = () => true;\n    }\n    if (options.methods[PageLifecycle.ON_SAVE_EXIT_STATE] === undefined) {\n        options.methods[PageLifecycle.ON_SAVE_EXIT_STATE] = function () {\n            const hook = this[toHiddenField(PageLifecycle.ON_SAVE_EXIT_STATE)];\n            if (hook) {\n                return hook();\n            }\n            return { data: undefined };\n        };\n        /* istanbul ignore next -- @preserve */\n        options.methods.__isInjectedExitStateHook__ = () => true;\n    }\n    options.methods[PageLifecycle.ON_LOAD] = createPageLifecycle(options, PageLifecycle.ON_LOAD);\n    options.methods[PageLifecycle.ON_PULL_DOWN_REFRESH] = createPageLifecycle(options, PageLifecycle.ON_PULL_DOWN_REFRESH);\n    options.methods[PageLifecycle.ON_REACH_BOTTOM] = createPageLifecycle(options, PageLifecycle.ON_REACH_BOTTOM);\n    options.methods[PageLifecycle.ON_TAB_ITEM_TAP] = createPageLifecycle(options, PageLifecycle.ON_TAB_ITEM_TAP);\n    if (options.pageLifetimes === undefined) {\n        options.pageLifetimes = {};\n    }\n    options.pageLifetimes[SpecialLifecycleMap[PageLifecycle.ON_SHOW]] =\n        createSpecialPageLifecycle(options, PageLifecycle.ON_SHOW);\n    options.pageLifetimes[SpecialLifecycleMap[PageLifecycle.ON_HIDE]] =\n        createSpecialPageLifecycle(options, PageLifecycle.ON_HIDE);\n    options.pageLifetimes[SpecialLifecycleMap[PageLifecycle.ON_RESIZE]] =\n        createSpecialPageLifecycle(options, PageLifecycle.ON_RESIZE);\n    options.pageLifetimes[SpecialLifecycleMap[PageLifecycle.ON_ROUTE_DONE]] =\n        createSpecialPageLifecycle(options, PageLifecycle.ON_ROUTE_DONE);\n    if (properties) {\n        if (options.observers === undefined) {\n            options.observers = {};\n        }\n        properties.forEach((property) => {\n            const originObserver = options.observers[property];\n            options.observers[property] = function (value) {\n                // Observer executes before attached\n                if (this.__props__) {\n                    this.__props__[property] = value;\n                }\n                if (originObserver !== undefined) {\n                    originObserver.call(this, value);\n                }\n            };\n        });\n    }\n    // eslint-disable-next-line new-cap\n    return Component(options);\n}\nfunction createComponentLifecycle(options, lifecycle) {\n    const originLifecycle = options.lifetimes[lifecycle] || options[lifecycle];\n    return createLifecycle(lifecycle, originLifecycle);\n}\nfunction createPageLifecycle(options, lifecycle) {\n    const originLifecycle = options.methods[lifecycle];\n    return createLifecycle(lifecycle, originLifecycle);\n}\nfunction createSpecialPageLifecycle(options, lifecycle) {\n    const originLifecycle = options.pageLifetimes[SpecialLifecycleMap[lifecycle]];\n    return createLifecycle(lifecycle, originLifecycle);\n}\nfunction createLifecycle(lifecycle, originLifecycle) {\n    const hiddenField = toHiddenField(lifecycle);\n    return function (...args) {\n        const hooks = this[hiddenField];\n        if (hooks) {\n            hooks.forEach((hook) => hook(...args));\n        }\n        if (originLifecycle !== undefined) {\n            originLifecycle.call(this, ...args);\n        }\n    };\n}\n\nconst pageHookWarn = 'Page specific lifecycle injection APIs can only be used during execution of setup() in definePage() or defineComponent().';\nconst onAppShow = createAppHook(AppLifecycle.ON_SHOW);\nconst onAppHide = createAppHook(AppLifecycle.ON_HIDE);\nconst onAppError = createAppHook(AppLifecycle.ON_ERROR);\nconst onPageNotFound = createAppHook(AppLifecycle.ON_PAGE_NOT_FOUND);\nconst onUnhandledRejection = createAppHook(AppLifecycle.ON_UNHANDLED_REJECTION);\nconst onThemeChange = createAppHook(AppLifecycle.ON_THEME_CHANGE);\nconst onShow = createPageHook(PageLifecycle.ON_SHOW);\nconst onHide = createPageHook(PageLifecycle.ON_HIDE);\nconst onUnload = createPageHook(PageLifecycle.ON_UNLOAD);\nconst onRouteDone = createPageHook(PageLifecycle.ON_ROUTE_DONE);\nconst onPullDownRefresh = createPageHook(PageLifecycle.ON_PULL_DOWN_REFRESH);\nconst onReachBottom = createPageHook(PageLifecycle.ON_REACH_BOTTOM);\nconst onResize = createPageHook(PageLifecycle.ON_RESIZE);\nconst onTabItemTap = createPageHook(PageLifecycle.ON_TAB_ITEM_TAP);\nconst onPageScroll = (hook) => {\n    const currentInstance = getCurrentInstance();\n    /* istanbul ignore else -- @preserve  */\n    if (currentInstance) {\n        /* istanbul ignore else -- @preserve   */\n        if (currentInstance.__listenPageScroll__) {\n            injectHook(currentInstance, PageLifecycle.ON_PAGE_SCROLL, hook);\n        }\n        else {\n            console.warn('onPageScroll() hook only works when `listenPageScroll` is configured to true.');\n        }\n    }\n    else {\n        console.warn(pageHookWarn);\n    }\n};\nconst onShareAppMessage = (hook) => {\n    const currentInstance = getCurrentInstance();\n    /* istanbul ignore else -- @preserve  */\n    if (currentInstance) {\n        /* istanbul ignore else -- @preserve  */\n        if (currentInstance[PageLifecycle.ON_SHARE_APP_MESSAGE] &&\n            currentInstance.__isInjectedShareToOthersHook__) {\n            const hiddenField = toHiddenField(PageLifecycle.ON_SHARE_APP_MESSAGE);\n            /* istanbul ignore else -- @preserve  */\n            if (currentInstance[hiddenField] === undefined) {\n                currentInstance[hiddenField] = hook;\n            }\n            else {\n                console.warn('onShareAppMessage() hook can only be called once.');\n            }\n        }\n        else {\n            console.warn('onShareAppMessage() hook only works when `onShareAppMessage` option is not exist and `canShareToOthers` is configured to true.');\n        }\n    }\n    else {\n        console.warn(pageHookWarn);\n    }\n};\nconst onShareTimeline = (hook) => {\n    const currentInstance = getCurrentInstance();\n    /* istanbul ignore else -- @preserve  */\n    if (currentInstance) {\n        /* istanbul ignore else -- @preserve  */\n        if (currentInstance[PageLifecycle.ON_SHARE_TIMELINE] &&\n            currentInstance.__isInjectedShareToTimelineHook__) {\n            const hiddenField = toHiddenField(PageLifecycle.ON_SHARE_TIMELINE);\n            /* istanbul ignore else -- @preserve  */\n            if (currentInstance[hiddenField] === undefined) {\n                currentInstance[hiddenField] = hook;\n            }\n            else {\n                console.warn('onShareTimeline() hook can only be called once.');\n            }\n        }\n        else {\n            console.warn('onShareTimeline() hook only works when `onShareTimeline` option is not exist and `canShareToTimeline` is configured to true.');\n        }\n    }\n    else {\n        console.warn(pageHookWarn);\n    }\n};\nconst onAddToFavorites = (hook) => {\n    const currentInstance = getCurrentInstance();\n    /* istanbul ignore else -- @preserve  */\n    if (currentInstance) {\n        /* istanbul ignore else -- @preserve  */\n        if (currentInstance.__isInjectedFavoritesHook__) {\n            const hiddenField = toHiddenField(PageLifecycle.ON_ADD_TO_FAVORITES);\n            /* istanbul ignore else -- @preserve  */\n            if (currentInstance[hiddenField] === undefined) {\n                currentInstance[hiddenField] = hook;\n            }\n            else {\n                console.warn('onAddToFavorites() hook can only be called once.');\n            }\n        }\n        else {\n            console.warn('onAddToFavorites() hook only works when `onAddToFavorites` option is not exist.');\n        }\n    }\n    else {\n        console.warn(pageHookWarn);\n    }\n};\nconst onSaveExitState = (hook) => {\n    const currentInstance = getCurrentInstance();\n    /* istanbul ignore else -- @preserve  */\n    if (currentInstance) {\n        /* istanbul ignore else -- @preserve  */\n        if (currentInstance.__isInjectedExitStateHook__) {\n            const hiddenField = toHiddenField(PageLifecycle.ON_SAVE_EXIT_STATE);\n            /* istanbul ignore else -- @preserve  */\n            if (currentInstance[hiddenField] === undefined) {\n                currentInstance[hiddenField] = hook;\n            }\n            else {\n                console.warn('onSaveExitState() hook can only be called once.');\n            }\n        }\n        else {\n            console.warn('onSaveExitState() hook only works when `onSaveExitState` option is not exist.');\n        }\n    }\n    else {\n        console.warn(pageHookWarn);\n    }\n};\nconst onReady = (hook) => {\n    const currentInstance = getCurrentInstance();\n    /* istanbul ignore else -- @preserve  */\n    if (currentInstance) {\n        injectHook(currentInstance, PageLifecycle.ON_READY, hook);\n    }\n    else {\n        console.warn('onReady() hook can only be called during execution of setup() in definePage() or defineComponent().');\n    }\n};\nconst onLoad = createComponentHook(PageLifecycle.ON_LOAD);\nconst onMove = createComponentHook(ComponentLifecycle.MOVED);\nconst onDetach = createComponentHook(ComponentLifecycle.DETACHED);\nconst onError = createComponentHook(ComponentLifecycle.ERROR);\nfunction createAppHook(lifecycle) {\n    return (hook) => {\n        /* istanbul ignore else -- @preserve  */\n        if (currentApp) {\n            injectHook(currentApp, lifecycle, hook);\n        }\n        else {\n            console.warn('App specific lifecycle injection APIs can only be used during execution of setup() in createApp().');\n        }\n    };\n}\nfunction createPageHook(lifecycle) {\n    return (hook) => {\n        const currentInstance = getCurrentInstance();\n        /* istanbul ignore else -- @preserve  */\n        if (currentInstance) {\n            injectHook(currentInstance, lifecycle, hook);\n        }\n        else {\n            console.warn(pageHookWarn);\n        }\n    };\n}\nfunction createComponentHook(lifecycle) {\n    return (hook) => {\n        /* istanbul ignore else -- @preserve  */\n        if (currentComponent) {\n            injectHook(currentComponent, lifecycle, hook);\n        }\n        else {\n            console.warn('Component specific lifecycle injection APIs can only be used during execution of setup() in defineComponent().');\n        }\n    };\n}\nfunction injectHook(currentInstance, lifecycle, hook) {\n    const hiddenField = toHiddenField(lifecycle);\n    if (currentInstance[hiddenField] === undefined) {\n        currentInstance[hiddenField] = [];\n    }\n    currentInstance[hiddenField].push(hook);\n}\n\nexports.EffectScope = EffectScope;\nexports.ReactiveEffect = ReactiveEffect;\nexports.TrackOpTypes = TrackOpTypes;\nexports.TriggerOpTypes = TriggerOpTypes;\nexports.computed = computed;\nexports.createApp = createApp;\nexports.customRef = customRef;\nexports.defineComponent = defineComponent;\nexports.definePage = definePage;\nexports.effect = effect;\nexports.effectScope = effectScope;\nexports.getCurrentScope = getCurrentScope;\nexports.getCurrentWatcher = getCurrentWatcher;\nexports.inject = inject;\nexports.isProxy = isProxy;\nexports.isReactive = isReactive;\nexports.isReadonly = isReadonly;\nexports.isRef = isRef;\nexports.isShallow = isShallow;\nexports.markRaw = markRaw;\nexports.nextTick = nextTick;\nexports.onAddToFavorites = onAddToFavorites;\nexports.onAppError = onAppError;\nexports.onAppHide = onAppHide;\nexports.onAppShow = onAppShow;\nexports.onDetach = onDetach;\nexports.onError = onError;\nexports.onHide = onHide;\nexports.onLoad = onLoad;\nexports.onMove = onMove;\nexports.onPageNotFound = onPageNotFound;\nexports.onPageScroll = onPageScroll;\nexports.onPullDownRefresh = onPullDownRefresh;\nexports.onReachBottom = onReachBottom;\nexports.onReady = onReady;\nexports.onResize = onResize;\nexports.onRouteDone = onRouteDone;\nexports.onSaveExitState = onSaveExitState;\nexports.onScopeDispose = onScopeDispose;\nexports.onShareAppMessage = onShareAppMessage;\nexports.onShareTimeline = onShareTimeline;\nexports.onShow = onShow;\nexports.onTabItemTap = onTabItemTap;\nexports.onThemeChange = onThemeChange;\nexports.onUnhandledRejection = onUnhandledRejection;\nexports.onUnload = onUnload;\nexports.onWatcherCleanup = onWatcherCleanup;\nexports.provide = provide;\nexports.proxyRefs = proxyRefs;\nexports.reactive = reactive;\nexports.readonly = readonly;\nexports.ref = ref;\nexports.shallowReactive = shallowReactive;\nexports.shallowReadonly = shallowReadonly;\nexports.shallowRef = shallowRef;\nexports.stop = stop;\nexports.toRaw = toRaw;\nexports.toRef = toRef;\nexports.toRefs = toRefs;\nexports.toValue = toValue;\nexports.triggerRef = triggerRef;\nexports.unref = unref;\nexports.watch = watch;\nexports.watchEffect = watchEffect;\nexports.watchPostEffect = watchPostEffect;\nexports.watchSyncEffect = watchSyncEffect;\n"]}